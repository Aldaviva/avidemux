// automatically generated by admSerialization.py, do not edit!
#include "ADM_default.h"
#include "ADM_paramList.h"
#include "ADM_coreJson.h"
#include "x264_encoder.h"
bool  x264_encoder_jserialize(const char *file, const x264_encoder *key){
admJson json;
json.addBool("useAdvancedConfiguration",key->useAdvancedConfiguration);
json.addNode("general");
json.addCompressParam("params",key->general.params);
json.addUint32("threads",key->general.threads);
json.addString("preset",key->general.preset);
json.addString("tuning",key->general.tuning);
json.addString("profile",key->general.profile);
json.addBool("fast_decode",key->general.fast_decode);
json.addBool("zero_latency",key->general.zero_latency);
json.addBool("fast_first_pass",key->general.fast_first_pass);
json.addBool("blueray_compatibility",key->general.blueray_compatibility);
json.addBool("fake_interlaced",key->general.fake_interlaced);
json.endNode();
json.addInt32("level",key->level);
json.addNode("vui");
json.addUint32("sar_height",key->vui.sar_height);
json.addUint32("sar_width",key->vui.sar_width);
json.endNode();
json.addUint32("MaxRefFrames",key->MaxRefFrames);
json.addUint32("MinIdr",key->MinIdr);
json.addUint32("MaxIdr",key->MaxIdr);
json.addUint32("i_scenecut_threshold",key->i_scenecut_threshold);
json.addBool("intra_refresh",key->intra_refresh);
json.addUint32("MaxBFrame",key->MaxBFrame);
json.addUint32("i_bframe_adaptive",key->i_bframe_adaptive);
json.addUint32("i_bframe_bias",key->i_bframe_bias);
json.addUint32("i_bframe_pyramid",key->i_bframe_pyramid);
json.addBool("b_deblocking_filter",key->b_deblocking_filter);
json.addInt32("i_deblocking_filter_alphac0",key->i_deblocking_filter_alphac0);
json.addInt32("i_deblocking_filter_beta",key->i_deblocking_filter_beta);
json.addBool("cabac",key->cabac);
json.addBool("interlaced",key->interlaced);
json.addBool("constrained_intra",key->constrained_intra);
json.addBool("tff",key->tff);
json.addBool("fake_interlaced",key->fake_interlaced);
json.addNode("analyze");
json.addBool("b_8x8",key->analyze.b_8x8);
json.addBool("b_i4x4",key->analyze.b_i4x4);
json.addBool("b_i8x8",key->analyze.b_i8x8);
json.addBool("b_p8x8",key->analyze.b_p8x8);
json.addBool("b_p16x16",key->analyze.b_p16x16);
json.addBool("b_b16x16",key->analyze.b_b16x16);
json.addUint32("weighted_pred",key->analyze.weighted_pred);
json.addBool("weighted_bipred",key->analyze.weighted_bipred);
json.addUint32("direct_mv_pred",key->analyze.direct_mv_pred);
json.addUint32("chroma_offset",key->analyze.chroma_offset);
json.addUint32("me_method",key->analyze.me_method);
json.addUint32("me_range",key->analyze.me_range);
json.addInt32("mv_range",key->analyze.mv_range);
json.addInt32("mv_range_thread",key->analyze.mv_range_thread);
json.addUint32("subpel_refine",key->analyze.subpel_refine);
json.addBool("chroma_me",key->analyze.chroma_me);
json.addBool("mixed_references",key->analyze.mixed_references);
json.addUint32("trellis",key->analyze.trellis);
json.addFloat("psy_rd",key->analyze.psy_rd);
json.addFloat("psy_trellis",key->analyze.psy_trellis);
json.addBool("fast_pskip",key->analyze.fast_pskip);
json.addBool("dct_decimate",key->analyze.dct_decimate);
json.addUint32("noise_reduction",key->analyze.noise_reduction);
json.addBool("psy",key->analyze.psy);
json.addUint32("intra_luma",key->analyze.intra_luma);
json.addUint32("inter_luma",key->analyze.inter_luma);
json.endNode();
json.addNode("ratecontrol");
json.addUint32("rc_method",key->ratecontrol.rc_method);
json.addUint32("qp_constant",key->ratecontrol.qp_constant);
json.addUint32("qp_min",key->ratecontrol.qp_min);
json.addUint32("qp_max",key->ratecontrol.qp_max);
json.addUint32("qp_step",key->ratecontrol.qp_step);
json.addUint32("bitrate",key->ratecontrol.bitrate);
json.addFloat("rate_tolerance",key->ratecontrol.rate_tolerance);
json.addUint32("vbv_max_bitrate",key->ratecontrol.vbv_max_bitrate);
json.addUint32("vbv_buffer_size",key->ratecontrol.vbv_buffer_size);
json.addUint32("vbv_buffer_init",key->ratecontrol.vbv_buffer_init);
json.addFloat("ip_factor",key->ratecontrol.ip_factor);
json.addFloat("pb_factor",key->ratecontrol.pb_factor);
json.addUint32("aq_mode",key->ratecontrol.aq_mode);
json.addFloat("aq_strength",key->ratecontrol.aq_strength);
json.addBool("mb_tree",key->ratecontrol.mb_tree);
json.addUint32("lookahead",key->ratecontrol.lookahead);
json.endNode();
return json.dumpToFile(file);
};
bool  x264_encoder_jdeserialize(const char *file, const ADM_paramList *tmpl,x264_encoder *key){
admJsonToCouple json;
CONFcouple *c=json.readFromFile(file);
if(!c) {ADM_error("Cannot read json file");return false;}
bool r= ADM_paramLoadPartial(c,tmpl,key);
delete c;
return r;
};
